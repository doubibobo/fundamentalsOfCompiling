+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
实验要求
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
LL1算法的实现：
1、文法要求：
（1）从文件读入，每条产生式占用一行
（2）文法为LL(1)文法
（3）默认不含有左递归（包括直接左递归和间接左递归***）
2、从文件中读入文法，从键盘上输入待分析的符号串，采用 LL(1)分析算法判断该符号串是否为该文法的句子

+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
算法分析过程
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
0：从文件种读取文法并且进行存储，采用map<char, vector<string> > 类型的数据结构，并取得所有的终结符和非终结符
1：识别出所有的终结符和非终结符之后，建立vector<string> wf[]的数据结构便于后续运算，与此同时，求出非终结符的first集合------>递归方式
2：求出follow集合，规则如下：------>建立合理数据结构，采用递归方式
  a：对于文法的开始符号S，置'#'于follow(S)中
  b：若A->(@a)B(@b)是一个产生式，则把first(@b) - {一部修} 加至follow中
  c：若A->(@a)B是一个产生式，或者A->(@a)B(@b)是一个产生式而(@b)能够推导出一部修，则把follow(A)加到follow(B)中
3：构造LL1分析表，规则如下：
  a：对于文法G的每一个产生式A->(@a)执行第2步和第3步
  b：对于每个终结符a是属于first(@A)，把A->(@a)加入到M[A，a]中
  c：如果一部修属于first(@a)，则对于任何b属于follow(@b)，把A->加入到M[A，b]中
  d：把没有定义的打上出错标志，默认不初始化，即为空
4：分析过程
  a：符号栈初始化，将默认的第一项入栈
  b：通过符号栈栈顶和输出串第一位首字符查表得到产生式，将产生式的右部逆序入栈，不断进行此过程知道符号栈出现终结符
  c：出现终结符，符号栈出栈，符号串右移一位，如果产生式右部分不是一部修，则只将符号栈出栈
  d：符号栈为空和输入串分析完毕，算法结束
  
  
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
求解first、follow集合遇到的问题
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
0: 最初按照课本上的顺序，求出每一个非终结符的first集合，不成想
   在求解follow集合的时候需要用到每一个产生式的first集合，又不
   想改之前的代码，于是又单独求了一遍，冗余，待优化
1：在求解first和follow集合的时候，采用了两个数据结构如下
	map<int, set<string> > subChar;
	map<int, set<char> > preorderChar;
	这是因为今天在了解搜索引擎是如何快速高效的爬取网页中数据的
	时候，发现使用反转列表实现的，即在存储一个单词在哪些网页出
	现，在什么位置出现。这里的preorderChar表示的是每一个非终结
	符对应产生式的第一个字符，subChar是每一个字符后面跟的字符。
	关于subChar，本来是设计了数据结构Node存储，如下
	// 文法简易数据结构
	struct Node {
		int which;      // 是哪个非终结符对应的文法
		int where;      // 对应那个终结符的第几条产生式
		bool flag;      // 右侧是否为一部修系统，初始化为false，默认不是
	};
	但是在应用set<Node>时候出错，故将其改为长度为四的字符串
  
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
数据结构
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// 文法中出现的非终结符对应的int数据类型
map<char, int> VN;

// 文法中出现的终结符对应的int数据类型
map<char, int> VT;

// 从文件中读取的没有初始化的文法（利用前面实验读取文件的模块）
map<char, vector<string> > input;

// 文法存储
vector<string> wf[];

// first集合，运用其自动去重特点
set<char> first;

// follow集合，运用其自动去重特点
set<char> follow;

// 构造LL1预测分析表
char LL1[][];

// 符号栈
stack<char> symbol;

// 输入串
string waitForAnalysis;


