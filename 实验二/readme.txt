+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
实验要求
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
LL1算法的实现：
1、文法要求：
（1）从文件读入，每条产生式占用一行
（2）文法为LL(1)文法
（3）默认不含有左递归（包括直接左递归和间接左递归***）
2、从文件中读入文法，从键盘上输入待分析的符号串，采用 LL(1)分析算法判断该符号串是否为该文法的句子

+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
算法分析过程
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
0：从文件种读取文法并且进行存储，采用map<char, vector<string> > 类型的数据结构，并取得所有的终结符和非终结符
1：识别出所有的终结符和非终结符之后，建立vector<string> wf[]的数据结构便于后续运算，与此同时，求出非终结符的first集合------>递归方式
2：求出follow集合，规则如下：------>建立合理数据结构，采用递归方式
  a：对于文法的开始符号S，置'#'于follow(S)中
  b：若A->(@a)B(@b)是一个产生式，则把first(@b) - {一部修} 加至follow中
  c：若A->(@a)B是一个产生式，或者A->(@a)B(@b)是一个产生式而(@b)能够推导出一部修，则把follow(A)加到follow(B)中
3：构造LL1分析表，规则如下：
  a：对于文法G的每一个产生式A->(@a)执行第2步和第3步
  b：对于每个终结符a是属于first(@A)，把A->(@a)加入到M[A，a]中
  c：如果一部修属于first(@a)，则对于任何b属于follow(@b)，把A->加入到M[A，b]中
  d：把没有定义的打上出错标志，默认不初始化，即为空
4：分析过程
  a：符号栈初始化，将默认的第一项入栈
  b：通过符号栈栈顶和输出串第一位首字符查表得到产生式，将产生式的右部逆序入栈，不断进行此过程知道符号栈出现终结符
  c：出现终结符，符号栈出栈，符号串右移一位，如果产生式右部分不是一部修，则只将符号栈出栈
  d：符号栈为空和输入串分析完毕，算法结束
  
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
数据结构
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// 文法中出现的非终结符对应的int数据类型
map<char, int> VN;

// 文法中出现的终结符对应的int数据类型
map<char, int> VT;

// 从文件中读取的没有初始化的文法（利用前面实验读取文件的模块）
map<char, vector<string> > input;

// 文法存储
vector<string> wf[];

// first集合，运用其自动去重特点
set<char> first;

// follow集合，运用其自动去重特点
set<char> follow;

// 构造LL1预测分析表
char LL1[][];

// 符号栈
stack<char> symbol;

// 输入串
string waitForAnalysis；

  


