LL0文法编程实现
要求：
0、判断是否是LR（0）型的文法
1、未知文法，但是输入的文法能够使用LR(0)
2、文法可以使用文件进行输入，也可以通过手动输入
3、做出其LR分析表
4、输入一个串，根据LR分析表，画出LR分析器的工作过程
5、使用C++来实现（个人要求）

过程：
==========================================================================================================================
初始化
==========================================================================================================================
0、将文法从文件当中读出来存储到map<char, vector<string> >类型的数据结构中
1、将文法进行拓展——————————————————进行文法的编号
2、建立一个map<char, int>的一一对应，便于 wf 的识别和处理
3、将这个数据结构转化成为string类型数组 string wf[str[map.size()]], 每一个元素的下标与map中的左边一一对应，作为最终文法输入的处理
	根据敲代码时候的实时要求，发现不能这样进行转换，应该是vector<string> wf[str[map.size()]]-------->优化，文法读入时
4、将所有文法加上活前缀，构造整个文法的项目，使用 node 结构体，如下node结构体的定义（于第三步同步进行）

==========================================================================================================================
求解DFA并且判断
==========================================================================================================================
5、求出项目集规范族使用项目集合closure函数和goto(Ix, A)
    1）从初始状态开始递归求解I0
    2）使用goto(Ix, A) 递归求解出DFA
    3）项目集规范族求解完毕

6、判断是否是LR(0)文法，看是否存在规约规约冲突和移进规约冲突，是则继续，不是则返回

==========================================================================================================================
填写LR(0)分析表
==========================================================================================================================
7、遍历DFA, 边遍历边进行填表（DFA的构造也即是LR(0)分析表的构造过程，需要思考）
    先填写一个状态，再遍历这个状态构造下一个状态！
==========================================================================================================================
查LR(0)分析表，并且分析一个具体的符号串
==========================================================================================================================







==========================================================================================================================
数据结构
==========================================================================================================================
// 文法中加了活前缀的句型
struct Node {
    int which;  // 知道是上述第几条
    int number;	// 知道是上述第几条的哪一个
    int where;  // 知道活前缀在文法中的位置
    char next;  // 活前缀后面的字符，用来判断状态转移
    boolean flag;   // 是否为可规约活前缀，默认为0不可规约
};

// DFA
struct Linked DFA[N];   //N 表示状态集合编号

// 表示DFA中的每一个状态
struct simple {
    char word;      // 识别的符号
    Linked* first;  // 第一个活前缀项目
};

// 表示DFA中每一个状态的每一个元素
struct Linked {
    Node* own;
    Linked* theNext;
};

// 文法中出现的非终结符对应的int数据类型
map<char, int> daxie;

// 文法中出现的终结符对应的int数据类型
map<char, int> xiaoxie;

// 从文件中读取的没有初始化的文法（利用前面实验读取文件的模块）
map<char, vector<string> > input;

// 经过处理后的文法
string wf[str[map.size()]] wenfa;

// 文法所有经过活前缀处理的句型
struct Node* allNode[];

// LR(0) 分析表，约定如果是移进项目，则存储字符'0'-'9'，如果是规约项目，则存储文法编号+'A', 如果是接受项目，则存储$，列需要xiaoxie，daxie数据结构的一一对应
char analisy[N][N];

// 状态栈
stack<int> state;

// 符号栈
stack<char> symbol;

// 输入串
string waitForAnalysis；

++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
第一版代码(2018-5-27)存在的问题：不能判断某个文法是不是LR1文法；终结符只能识别小写英文字母；不能处理含有左递归的文法
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
如何判断一个文法是不是LR1文法
1)文法不存在规约规约冲突。  ------------------------通过活前缀来选择文法，如果出现文法相同的情形，则不是LR1文法。
2)文法不存在移进规约冲突。  ------------------------一个文法不是其余文法的前缀。